# readResultsFromReportFile ----------------------------------------------------
readResultsFromReportFile <- function # readResultsFromReportFile
### reads an EPANET report file and returns a list with node and link data
(
  reportFile,
  ### full path to report file, generated by EPANET
  warn = TRUE
  ### if TRUE, a warning is given if no Node or Link results were found in the
  ### report file.
)
{  
  reportLines <- readLines(reportFile)  
  
  list(
    nodeData = .extractDataOfType(reportLines, "Node", warn = warn), 
    linkData = .extractDataOfType(reportLines, "Link", warn = warn)
  )
  ### list with elements \emph{nodeData} containing a data frame with node
  ### results and \emph{linkData} containing a data frame with link results
}

# .extractDataOfType -----------------------------------------------------------
.extractDataOfType <- function
(
  reportLines, 
  ### text lines read from report file
  objectType,
  ### "Node" or "Link"
  warn = TRUE
)
{
  indices <- grep(paste(objectType, "Results at"), reportLines)
  
  # if there are no results for each timestep check for statistical data blocks
  
  if (length(indices) == 0) {
    pattern <- paste(
      "MINIMUM|MAXIMUM|AVERAGE|DIFFERENTIAL", objectType, "Results:")
    indices <- grep(pattern, reportLines)
    is.statistic <- TRUE
  } else {
    is.statistic <- FALSE
  }
  
  if (length(indices) == 0) {
    if (warn) {
      warning("No ", objectType, " data found in report file.")
    }
    return (NULL)
  }
  
  startindices <- indices + 5  
  
  startindex <- startindices[1]
  
  indicesEmpty <- grep("^\\s*$", reportLines)
  
  endindex <- min(indicesEmpty[indicesEmpty > startindex]) - 1
  
  numberOfElements <- endindex - startindex + 1
  
  blockindices <- .getBlockIndices(startindices, blocksize = numberOfElements)
  
  textblock <- reportLines[blockindices]

  headerInfo <- .extractVariableAndUnitNames(reportLines, index = indices[1])
  
  col.number <- length(headerInfo$variableNames) + 2
  col.names <- paste("V", seq_len(col.number), sep = "")
  
  # from the length of col.names the number of columns is determined, see
  # ?read.table to which arguments are passed on
  dataFrame <- csvTextToDataFrame(
    textblock, fill = TRUE, col.names = col.names, stringsAsFactors = FALSE)
  
  names(dataFrame) <- c(objectType, headerInfo$variableNames, "Type")
  
  if (! is.statistic) {
    timestamps.txt <- .extractTimestamps(reportLines, indices)    
    dataFrame$time.txt <- rep(timestamps.txt, each = numberOfElements)  
    
    dataFrame$time.s <- .hhmmssToSeconds(dataFrame$time.txt)
    
    dataFrame$time.h <- dataFrame$time.s / 3600  
    
    time.columns <- c("time.s", "time.h", "time.txt")  
    
    dataFrame[, c(time.columns, setdiff(names(dataFrame), time.columns))]
  }
  else {
    headerRow <- hsTrim(reportLines[indices[1]])
    
    data.frame(
      Statistic = strsplit(headerRow, " ")[[1]][1],
      dataFrame,
      stringsAsFactors = FALSE
    )
  }    
}

# .getBlockIndices -------------------------------------------------------------
.getBlockIndices <- function(starts, blocksize)
{
  rep(starts, each = blocksize) + rep(seq_len(blocksize) - 1, length(starts))
}

# .extractVariableAndUnitNames -------------------------------------------------
.extractVariableAndUnitNames <- function(reportLines, index)
{ 
  variableNames <- hsTrim(reportLines[index + 2])
  unitNames <- hsTrim(reportLines[index + 3])
  
  variableNames <- strsplit(variableNames, " ")[[1]]  
  unitNames <- strsplit(unitNames, " ")[[1]][-1]
  
  list(
    variableNames = variableNames,
    unitNames = unitNames
  )
}

# .extractTimestamps -----------------------------------------------------------
.extractTimestamps <- function(reportLines, indices)
{
  sapply(strsplit(reportLines[indices], split = " "), "[[", 6)  
}

# .hhmmssToSeconds -------------------------------------------------------------
.hhmmssToSeconds <- function(x)
{
  sapply(strsplit(x, ":"), FUN = function(x) sum(as.integer(x) *c(3600, 60, 1)))
}
