# readResultsFromReportFile ----------------------------------------------------

#' Read Results From Report File
#' 
#' reads an EPANET report file and returns a list with node and link data
#' 
#' @param reportFile full path to report file, generated by EPANET
#' @param warn if TRUE, a warning is given if no Node or Link results were found
#'   in the report file.
#' 
#' @return list with elements \emph{nodeData} containing a data frame with node
#'   results and \emph{linkData} containing a data frame with link results
#' @export
readResultsFromReportFile <- function(reportFile, warn = TRUE)
{  
  reportLines <- readLines(reportFile)  
  
  list(
    nodeData = .extractDataOfType(reportLines, "Node", warn = warn), 
    linkData = .extractDataOfType(reportLines, "Link", warn = warn)
  )
}

# .extractDataOfType -----------------------------------------------------------
.extractDataOfType <- function(reportLines, objectType, warn = TRUE)
{
  indices <- grep(paste(objectType, "Results at"), reportLines)
  
  if (length(indices) == 0) {
    pattern <- paste("MINIMUM|MAXIMUM|AVERAGE|DIFFERENTIAL", 
                     objectType, "Results:")
    indices <- grep(pattern, reportLines)
    is.statistic <- TRUE
    
  } else {
    
    is.statistic <- FALSE
  }
  
  if (length(indices) == 0) {
    
    if (warn) {
      warning("No ", objectType, " data found in report file.")
    }
    
    return(NULL)
  }
  
  startindices <- indices + 5
  startindex <- startindices[1]
  indicesEmpty <- grep("^\\s*$", reportLines)
  endindex <- min(indicesEmpty[indicesEmpty > startindex]) - 1
  numberOfElements <- endindex - startindex + 1
  blockindices <- .getBlockIndices(startindices, blocksize = numberOfElements)
  textblock <- reportLines[blockindices]
  headerInfo <- .extractVariableAndUnitNames(reportLines, index = indices[1])
  col.number <- length(headerInfo$variableNames) + 2
  col.names <- paste("V", seq_len(col.number), sep = "")
  
  dataFrame <- kwb.utils::csvTextToDataFrame(
    textblock, fill = TRUE, col.names = col.names, 
    stringsAsFactors = FALSE
  )
  
  names(dataFrame) <- c(objectType, headerInfo$variableNames, "Type")
  
  if (! is.statistic) {
    
    timestamps.txt <- .extractTimestamps(reportLines, indices)
    dataFrame$time.txt <- rep(timestamps.txt, each = numberOfElements)
    dataFrame$time.s <- .hhmmssToSeconds(dataFrame$time.txt)
    dataFrame$time.h <- dataFrame$time.s/3600
    time.columns <- c("time.s", "time.h", "time.txt")
    
    dataFrame[, c(time.columns, setdiff(names(dataFrame), time.columns))]
    
  } else {
    
    headerRow <- kwb.utils::hsTrim(reportLines[indices[1]])
    
    data.frame(
      Statistic = strsplit(headerRow, " ")[[1]][1], 
      dataFrame, 
      stringsAsFactors = FALSE
    )
  }
}

# .getBlockIndices -------------------------------------------------------------
.getBlockIndices <- function(starts, blocksize)
{
  rep(starts, each = blocksize) + rep(seq_len(blocksize) - 1, length(starts))
}

# .extractVariableAndUnitNames -------------------------------------------------
.extractVariableAndUnitNames <- function(reportLines, index)
{
  variableNames <- kwb.utils::hsTrim(reportLines[index + 2])
  unitNames <- kwb.utils::hsTrim(reportLines[index + 3])
  variableNames <- strsplit(variableNames, " ")[[1]]
  unitNames <- strsplit(unitNames, " ")[[1]][-1]
  list(variableNames = variableNames, unitNames = unitNames)
}

# .extractTimestamps -----------------------------------------------------------
.extractTimestamps <- function(reportLines, indices)
{
  sapply(strsplit(reportLines[indices], split = " "), "[[", 6)
}

# .hhmmssToSeconds -------------------------------------------------------------
.hhmmssToSeconds <- function(x)
{
  sapply(strsplit(x, ":"), FUN = function(x) sum(as.integer(x) * c(3600, 60, 1)))
}
